\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english] {babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{url}
\usepackage{circuitikz}
\usepackage{subfig}
\usepackage[a4paper]{geometry}
\geometry{hscale=0.7,vscale=0.7,centering}
\usepackage{vmargin}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{moreverb}
\usepackage{listings}
\usepackage{qtree}
\graphicspath{{IMAGES/}}
\newtheorem{theorem}{Théorème}[section]
\newtheorem{defi}{Définition}[section]
\newtheorem{propri}{Propriété}[section]
\newtheorem{ex}{Exemple}[section]
\newtheorem{thesis}{Thèse}[section]
\newtheorem{cor}{Corollaire}[section]

\usepackage{color}

\definecolor{gris}{rgb}{0.95,0.95,0.95}


% Param�rage des listings
\lstset{basicstyle=\footnotesize\ttfamily}
\lstset{keywordstyle=\color[rgb]{0,0,1}\bfseries}
\lstset{identifierstyle=\color{black}}
\lstset{commentstyle=\color[rgb]{0,0.4,0}}
\lstset{stringstyle=\color[rgb]{0.7,0,0}}
\lstset{showstringspaces=false}
\lstset{showtabs=false}
\lstset{tabsize=3}
\lstset{extendedchars=true}
\lstset{breaklines=true}
\lstset{postbreak={}}
\lstset{breakautoindent=true}
\lstset{breakindent=0pt}
\lstset{xleftmargin=0.1cm}
\lstset{xrightmargin=0cm}
\lstset{frame=tb,rulecolor=\color[gray]{.4}}
\lstset{captionpos=b}
\lstset{aboveskip=0.5cm,belowskip=0.5cm}
\lstset{numbers=left}
\lstset{columns=fixed}



\newcommand{\code}[1]{\lstinline{#1}}

\setlength{\parskip}{.7em}

\begin{document}


\begin{flushleft}
\includegraphics[scale=0.3]{logo_ist.jpeg}
\end{flushleft}


\vspace{1cm}

\begin{center}{
\scshape{\LARGE Wolves and squirrel : Part 2 }}

\vspace{0.5cm}
\hbox{\raisebox{0.4em}{\vrule depth 0pt height 0.05cm width 16cm}}
{\setlength{\parskip}{0.2cm}

 \Huge
 \bfseries
 \LARGE  Parallel and Distributed Computing
 \\
CPD \\

\vspace{0.2cm}

}
\vspace{0.5cm}

\hbox{\raisebox{0.4em}{\vrule depth 0pt height 0.05cm width 16cm}}
\vspace{2.5cm}


\end{center}

\vspace{3cm}


\vfill
\begin{flushright}
\textbf{Group 30 :}\\
Cappart Quentin (77827)\\
Mikołaj Jakubowski (77610)\\
Paulo Tome (72419)\\

\end{flushright}
\newpage

\setcounter{page}{1}

\renewcommand\thepage{\arabic{page}}


\newpage

\section*{MPI Architecture}

Our program is based on a Master and Servant model.
In this model, we have two sorts of nodes, the master and the servants.
In few words, the master is the coordinator of the work, and the servants will deal only with a sub-board of the total board.
Let's describe all of this more concretely.

\paragraph{MPI Message}
~\\

We have severals type of messages between the master and the servants :

\begin{enumerate}
 \item \texttt{NEW\_BOARD(from:Position, to:Position)} : Message sent by the master to the servants to give them a part of the board.
 \item \texttt{UPDATE\_CELL(c : cell\_t)} : Message sent by the master or by the servants to notify a modification on particular cells.
 \item \texttt{FINISHED()} : Message sent by the master or by the servants to notify the finishing of a particular task.
 \item \texttt{START\_NEXT\_GENERATION(RED or BLACK)} : Message sent by the master to tell the servants to begin the computation
 of a new generation.
\end{enumerate}

\paragraph{Master}
~\\

There is only one master in the program. He's in charge of the coordination of all the work. He does the following actions :

\begin{lstlisting}
Load the world from the input file
Split the world in different parts (One per servant)
Send position of a sub-board to every servant.

for i in 0 -> 2*Nb of generations:
    Send START_NEXT_GENERATION(color) to every node
    Listen for incoming updates and save them
    Count received FINISHED messages
    if(count == Nb of slaves):
		break;
    Send stored updates to all servants
    Send FINISHED to all servants
    
Send FINISHED to all servants // all generations are finished
Listen for UPDATE_CELL and save them to master board
Count FINISHED messages
if(count == Nb of slaves):
    Print output
    Exit
\end{lstlisting}


\paragraph{Servants}
~\\

All the other computers are servants of the master. Each of them receives a sub-board. The distribution of the work follow this idea.
Each servants do the following actions :

\begin{lstlisting}
 Load the world from a file
 Listen for NEW_BOARD message to select a piece
 
 while true:
    Listen for message
    if(message = FINISHED):
		break;
    elif(message = START_NEXT_GENERATION(genInfo):
    Compute its part of the board
    Send UPDATE_CELL to the master the message with the modified cells
    Send FINISHED to the master
    Listen for UPDATE_CELL messages from master
    Update the cells and resolve conflicts
    Listen for FINISHED message from master
    
 Sends UPDATE_CELL to the master with all the cells.
 Exit
\end{lstlisting}

\section*{Conflict resolution}
Given that the algorithm keeps the same idea than the serial version, the way conflict resolution will be nearby the same. 
The only difference is in the sub-board edges where the servants need information about a part of the board that not belongs to them.
In these cases, it's the master that's in charge to send messages to ensure the consistency of the board.
\section*{Load balancing}
With this model, all servants receive a part of the board of the same size\footnote{Except the last, due to the remainder of the division.}
However, the number of dynamic elements in each parts is not taken into account for the shattering of the board. So it's possible
that some servants has more or less work to do.
\section*{Performances analysis}

The following array recaps the execution time of the MPI version with severals numbers of nodes in the cluster.
\begin{table}[!ht]
\centering
\begin{tabular}{|c||c|c|c|c|}
  \hline
    Instance     & 1 node (Serial)   & 2 nodes   & 4 nodes  & 8 nodes  \\
  \hline
    ex3.in       &       &  6 sec       & 8 sec       &  13 sec \\ 
  \hline
    world\_10.in &       &  5 sec      & 8 sec      &  \\ 
  \hline
   world\_100.in &       &   10 sec     &      &  \\ 
  \hline
  world\_1000.in &     &    6 min 1 sec   & 3 min 52 sec      & 3 min 19 sec  \\ 
  \hline
\end{tabular}
\caption{Performances for the different instances.}
\end{table}

We did these experiments on the \texttt{Borg} cluster with 2000 generations.
\\

At a first sight we can observe that the execution time tends to increase with the number of nodes for the small instances, and
to decrease for the big ones. This can be explained easily. The bottleneck of a distributed program is the cost of the communications
between the nodes. For the smallest instances, the gain of the distribution of task is overtaken by the cost of the communication.
Contrariwise, for the biggest, we can see the interest of the distribution. The computation of the board begins to be costly, and
the distribution between servants is useful. We can see it for the \texttt{world\_1000.in} instance where the execution time
significantly decreases.
	

\end{document}

